TCPDUMP(1)                                                          TCPDUMP(1)



NNAAMMEE
       tcpdump - dump traffic on a network

SSYYNNOOPPSSIISS
       ttccppdduummpp [ --AAbbddDDeeffhhggHHIIJJKKllLLnnNNooOOppPPqqRRSSttuuUUvvxxXX ] [ --BB _b_u_f_f_e_r___s_i_z_e ] [ --cc
       _c_o_u_n_t ]
               [ --CC _f_i_l_e___s_i_z_e ] [ --GG _r_o_t_a_t_e___s_e_c_o_n_d_s ] [ --FF _f_i_l_e ]
               [ --ii _i_n_t_e_r_f_a_c_e ] [ --jj _t_s_t_a_m_p___t_y_p_e ] [ --kk _(_m_e_t_a_d_a_t_a___a_r_g_) ]
               [ --mm _m_o_d_u_l_e ] [ --MM _s_e_c_r_e_t ]
               [ --rr _f_i_l_e ] [ --ss _s_n_a_p_l_e_n ] [ --TT _t_y_p_e ] [ --ww _f_i_l_e ]
               [ --WW _f_i_l_e_c_o_u_n_t ]
               [ --EE _s_p_i_@_i_p_a_d_d_r _a_l_g_o_:_s_e_c_r_e_t_,_._._.  ]
               [ --yy _d_a_t_a_l_i_n_k_t_y_p_e ] [ --zz _p_o_s_t_r_o_t_a_t_e_-_c_o_m_m_a_n_d ] [ --ZZ _u_s_e_r ]
               [ --QQ _p_a_c_k_e_t_-_m_e_t_a_d_a_t_a_-_f_i_l_t_e_r ]
               [ _e_x_p_r_e_s_s_i_o_n ]

DDEESSCCRRIIPPTTIIOONN
       _T_c_p_d_u_m_p prints out a description of the contents of packets on  a  net-
       work  interface  that match the boolean _e_x_p_r_e_s_s_i_o_n.  It can also be run
       with the --ww flag, which causes it to save the packet data to a file for
       later analysis, and/or with the --rr flag, which causes it to read from a
       saved packet file rather than to read packets from a network interface.
       It  can also be run with the --VV flag, which causes it to read a list of
       saved packet files. In all cases, only packets  that  match  _e_x_p_r_e_s_s_i_o_n
       will be processed by _t_c_p_d_u_m_p.

       _T_c_p_d_u_m_p  will,  if not run with the --cc flag, continue capturing packets
       until it is interrupted by a SIGINT signal (generated, for example,  by
       typing your interrupt character, typically control-C) or a SIGTERM sig-
       nal (typically generated with the kkiillll(1) command); if run with the  --cc
       flag,  it  will  capture packets until it is interrupted by a SIGINT or
       SIGTERM signal or the specified number of packets have been  processed.

       When _t_c_p_d_u_m_p finishes capturing packets, it will report counts of:

              packets ``captured'' (this is the number of packets that _t_c_p_d_u_m_p
              has received and processed);

              packets ``received by filter'' (the meaning of this  depends  on
              the  OS on which you're running _t_c_p_d_u_m_p, and possibly on the way
              the OS was configured - if a filter was specified on the command
              line,  on some OSes it counts packets regardless of whether they
              were matched by the filter expression and,  even  if  they  were
              matched  by the filter expression, regardless of whether _t_c_p_d_u_m_p
              has read and processed them yet, on other OSes  it  counts  only
              packets that were matched by the filter expression regardless of
              whether _t_c_p_d_u_m_p has read and processed them yet,  and  on  other
              OSes  it  counts  only  packets  that were matched by the filter
              expression and were processed by _t_c_p_d_u_m_p);

              packets ``dropped by kernel'' (this is  the  number  of  packets
              that  were dropped, due to a lack of buffer space, by the packet
              capture mechanism in the OS on which _t_c_p_d_u_m_p is running, if  the
              OS  reports that information to applications; if not, it will be
              reported as 0).

       On platforms that  support  the  SIGINFO  signal,  such  as  most  BSDs
       (including  Mac  OS  X)  and  Digital/Tru64  UNIX, it will report those
       counts when it receives a SIGINFO signal (generated,  for  example,  by
       typing your ``status'' character, typically control-T, although on some
       platforms, such as Mac OS X, the ``status'' character  is  not  set  by
       default,  so  you must set it with ssttttyy(1) in order to use it) and will
       continue capturing packets.

       Reading packets from a network interface may require that you have spe-
       cial  privileges; see the ppccaapp ((33PPCCAAPP)) man page for details.  Reading a
       saved packet file doesn't require special privileges.

OOPPTTIIOONNSS
       --AA     Print each packet (minus its link level header) in ASCII.  Handy
              for capturing web pages.

       --bb     Print the AS number in BGP packets in ASDOT notation rather than
              ASPLAIN notation.

       --BB     Set the operating system capture buffer size to _b_u_f_f_e_r___s_i_z_e,  in
              units of KiB (1024 bytes).

       --cc     Exit after receiving _c_o_u_n_t packets.

       --CC     Before  writing  a  raw  packet to a savefile, check whether the
              file is currently larger than _f_i_l_e___s_i_z_e and, if  so,  close  the
              current  savefile and open a new one.  Savefiles after the first
              savefile will have the name specified with the --ww flag,  with  a
              number after it, starting at 1 and continuing upward.  The units
              of  _f_i_l_e___s_i_z_e  are  millions  of  bytes  (1,000,000  bytes,  not
              1,048,576 bytes).

       --dd     Dump  the compiled packet-matching code in a human readable form
              to standard output and stop.

       --dddd    Dump packet-matching code as a CC program fragment.

       --dddddd   Dump packet-matching code as decimal numbers  (preceded  with  a
              count).

       --DD     Print the list of the network interfaces available on the system
              and on which _t_c_p_d_u_m_p can  capture  packets.   For  each  network
              interface,  a number and an interface name, possibly followed by
              a text description of the interface, is printed.  The  interface
              name  or the number can be supplied to the --ii flag to specify an
              interface on which to capture.

              This can be useful on systems that don't have a command to  list
              them  (e.g.,  Windows  systems, or UNIX systems lacking iiffccoonnffiigg
              --aa); the number can be useful on Windows 2000 and later systems,
              where the interface name is a somewhat complex string.

              The  --DD  flag will not be supported if _t_c_p_d_u_m_p was built with an
              older version of _l_i_b_p_c_a_p that lacks the ppccaapp__ffiinnddaallllddeevvss(()) func-
              tion.

       --ee     Print  the  link-level  header  on  each dump line.  This can be
              used, for example, to print MAC layer  addresses  for  protocols
              such as Ethernet and IEEE 802.11.

       --EE     Use _s_p_i_@_i_p_a_d_d_r _a_l_g_o_:_s_e_c_r_e_t for decrypting IPsec ESP packets that
              are addressed to _a_d_d_r and contain Security Parameter Index value
              _s_p_i. This combination may be repeated with comma or newline sep-
              aration.

              Note that setting the secret for IPv4 ESP packets  is  supported
              at this time.

              Algorithms  may  be  ddeess--ccbbcc,  33ddeess--ccbbcc,  bblloowwffiisshh--ccbbcc, rrcc33--ccbbcc,
              ccaasstt112288--ccbbcc, or nnoonnee.  The default is ddeess--ccbbcc.  The  ability  to
              decrypt  packets  is  only  present if _t_c_p_d_u_m_p was compiled with
              cryptography enabled.

              _s_e_c_r_e_t is the ASCII text for ESP secret key.  If preceded by 0x,
              then a hex value will be read.

              The  option assumes RFC2406 ESP, not RFC1827 ESP.  The option is
              only for debugging purposes, and the use of this option  with  a
              true  `secret'  key  is discouraged.  By presenting IPsec secret
              key onto command line you make it visible to others,  via  _p_s(1)
              and other occasions.

              In  addition  to  the  above syntax, the syntax _f_i_l_e _n_a_m_e may be
              used to have tcpdump read the provided  file  in.  The  file  is
              opened  upon receiving the first ESP packet, so any special per-
              missions that tcpdump may have been given  should  already  have
              been given up.

       --ff     Print  `foreign' IPv4 addresses numerically rather than symboli-
              cally (this option is intended to get around serious brain  dam-
              age  in Sun's NIS server -- usually it hangs forever translating
              non-local internet numbers).

              The test for `foreign' IPv4 addresses is  done  using  the  IPv4
              address  and  netmask of the interface on which capture is being
              done.  If that address or netmask are not available,  available,
              either  because the interface on which capture is being done has
              no address or netmask or because the capture is  being  done  on
              the  Linux  "any"  interface, which can capture on more than one
              interface, this option will not work correctly.

       --FF     Use _f_i_l_e as input for  the  filter  expression.   An  additional
              expression given on the command line is ignored.

       --gg     Do  not  insert  line  break after IP header in verbose mode for
              easier parsing.

       --GG     If specified, rotates the dump file specified with the --ww option
              every  _r_o_t_a_t_e___s_e_c_o_n_d_s  seconds.   Savefiles  will  have the name
              specified by --ww which should include a time format as defined by
              ssttrrffttiimmee(3).  If no time format is specified, each new file will
              overwrite the previous.

              If used in conjunction with the --CC option, filenames  will  take
              the form of `_f_i_l_e<count>'.

       --hh     Print  the  tcpdump  and  libpcap version strings, print a usage
              message, and exit.

       --HH     Attempt to detect 802.11s draft mesh headers.

       --ii     Listen on _i_n_t_e_r_f_a_c_e.

              If the --DD flag is supported, an interface number as  printed  by
              that flag can be used as the _i_n_t_e_r_f_a_c_e argument.

              On  Darwin  systems  version  13 or later, when the _i_n_t_e_r_f_a_c_e is
              unspecified, tcpdump will use  a  pseudo  interface  to  capture
              packets  on  a  set  of  interfaces  determined  by  the  kernel
              (excludes by default loopback and tunnel interfaces).

              Alternatively, to capture on more than one interface at a  time,
              one  may  use  "pktap" as the _i_n_t_e_r_f_a_c_e parameter followed by an
              optional list of comma separated  interface  names  to  include.
              For example, to capture on the loopback and en0 interface:

                     ttccppdduummpp --ii ppkkttaapp,,lloo00,,eenn00

              An  _i_n_t_e_r_f_a_c_e  argument  of  "all" or "pktap,all" can be used to
              capture packets from all interfaces, including loopback and tun-
              nel interfaces.

              A  pktap pseudo interface provides for packet metadata using the
              default PKTAP data link type and files are written in the  Pcap-
              ng file format.  The RAW data link type must be used to force to
              use the legacy ppccaapp--ssaavveeffiillee(5) file format with a ptkap  pseudo
              interface.   Note that captures on a ptkap pseudo interface will
              not be done in promiscuous mode.

              An _i_n_t_e_r_f_a_c_e argument of "iptap" can be used to capture  packets
              from  at  the IP layer.  This capture packets as they are passed
              to the input and output routines of the IPv4 and  IPv6  protocol
              handlers  of  the networking stack.  Note that captures will not
              be done in promiscuous mode.

              On other OSes,  if  unspecified,  _t_c_p_d_u_m_p  searches  the  system
              interface  list for the lowest numbered, configured up interface
              (excluding loopback).  Ties are broken by choosing the  earliest
              match.

              On  Linux  systems with 2.2 or later kernels, an _i_n_t_e_r_f_a_c_e argu-
              ment of ``any'' can be used to capture packets from  all  inter-
              faces.   Note  that  captures  on the ``any'' device will not be
              done in promiscuous mode.

              If the --DD flag is supported, an interface number as  printed  by
              that flag can be used as the _i_n_t_e_r_f_a_c_e argument.

       --II     Put  the  interface in "monitor mode"; this is supported only on
              IEEE 802.11 Wi-Fi interfaces, and supported only on some operat-
              ing systems.

              Note  that  in  monitor mode the adapter might disassociate from
              the network with which it's associated, so that you will not  be
              able to use any wireless networks with that adapter.  This could
              prevent accessing files on a network server, or  resolving  host
              names or network addresses, if you are capturing in monitor mode
              and are not connected to another network with another adapter.

              This flag will affect the output of the --LL flag.   If  --II  isn't
              specified,  only  those  link-layer  types available when not in
              monitor mode will be shown; if --II is specified, only those link-
              layer types available when in monitor mode will be shown.

       --jj     Set  the  time  stamp  type for the capture to _t_s_t_a_m_p___t_y_p_e.  The
              names to use for the time stamp types are given in  ppccaapp--ttssttaammpp--
              ttyyppee(7);  not  all  the  types  listed there will necessarily be
              valid for any given interface.

       --JJ     List the supported time stamp types for the interface and  exit.
              If  the time stamp type cannot be set for the interface, no time
              stamp types are listed.

       --kk     Control the display of packet metadata  via  an  optional  _m_e_t_a_-
              _d_a_t_a___a_r_g  argument.  This is useful when displaying packet saved
              in the pcap-ng file format or with interfaces that  support  the
              PKTAP data link type.

              By default, when the _m_e_t_a_d_a_t_a___a_r_g optional argument is not spec-
              ified, any available packet metadata information is printed out.

              The  _m_e_t_a_d_a_t_a___a_r_g  argument  controls  the  display  of specific
              packet metadata information using a flag word, where each  char-
              acter corresponds to a type of packet metadata as follows:

                     II     interface name (or interface ID)
                     NN     process name
                     PP     process ID
                     SS     service class
                     DD     direction
                     CC     comment

              This is an Apple modification.

       --KK     Don't attempt to verify IP, TCP, or UDP checksums.  This is use-
              ful for interfaces that perform some or all  of  those  checksum
              calculation  in  hardware; otherwise, all outgoing TCP checksums
              will be flagged as bad.

       --ll     Make stdout line buffered.  Useful if you want to see  the  data
              while capturing it.  E.g.,

                     ttccppdduummpp --ll || tteeee ddaatt

              or

                     ttccppdduummpp --ll >> ddaatt && ttaaiill --ff ddaatt

              Note  that on Windows,``line buffered'' means ``unbuffered'', so
              that WinDump will write each character  individually  if  --ll  is
              specified.

              --UU is similar to --ll in its behavior, but it will cause output to
              be ``packet-buffered'', so that the output is written to  stdout
              at  the  end of each packet rather than at the end of each line;
              this is buffered on all platforms, including Windows.

       --LL     List the known data link types for the interface, in the  speci-
              fied  mode,  and exit.  The list of known data link types may be
              dependent on the specified mode; for example, on some platforms,
              a  Wi-Fi interface might support one set of data link types when
              not in monitor mode (for example, it  might  support  only  fake
              Ethernet  headers,  or might support 802.11 headers but not sup-
              port 802.11 headers with radio information) and another  set  of
              data link types when in monitor mode (for example, it might sup-
              port 802.11 headers, or 802.11 headers with  radio  information,
              only in monitor mode).

       --mm     Load  SMI  MIB module definitions from file _m_o_d_u_l_e.  This option
              can be used several times to load several MIB modules into  _t_c_p_-
              _d_u_m_p.

       --MM     Use  _s_e_c_r_e_t  as a shared secret for validating the digests found
              in TCP segments with the TCP-MD5 option (RFC 2385), if  present.

       --nn     Don't  convert  addresses  (i.e.,  host addresses, port numbers,
              etc.) to names.

       --NN     Don't print domain name qualification of host names.   E.g.,  if
              you  give  this  flag then _t_c_p_d_u_m_p will print ``nic'' instead of
              ``nic.ddn.mil''.

       --oo     Print the ordinal number of the packet at the beginning  of  the
              line.

       --OO     Do  not  run the packet-matching code optimizer.  This is useful
              only if you suspect a bug in the optimizer.

       --PP     Use the pcap-ng file format when saving files.  Apple  modifica-
              tion.

       --pp     _D_o_n_'_t  put  the  interface into promiscuous mode.  Note that the
              interface might be in promiscuous mode for  some  other  reason;
              hence,  `-p'  cannot  be used as an abbreviation for `ether host
              {local-hw-addr} or ether broadcast'.

       --QQ     To specify a filter expression based on packet metadata informa-
              tion  like  interface  or  process  name.   Packet with matching
              packet metadata will be displayed or saved to a file.  See  sec-
              tion  PACKET  METADATA  FILTER for the syntax of packet metadata
              filter expressions.  This is an Apple addition.

       --qq     Quick (quiet?) output.  Print less protocol information so  out-
              put lines are shorter.

       --RR     Assume  ESP/AH packets to be based on old specification (RFC1825
              to RFC1829).  If specified, _t_c_p_d_u_m_p will not print  replay  pre-
              vention  field.   Since  there  is  no protocol version field in
              ESP/AH specification,  _t_c_p_d_u_m_p  cannot  deduce  the  version  of
              ESP/AH protocol.

       --rr     Read  packets  from _f_i_l_e (which was created with the --ww option).
              Standard input is used if _f_i_l_e is ``-''.

       --SS     Print absolute, rather than relative, TCP sequence numbers.

       --ss     Snarf _s_n_a_p_l_e_n bytes of data from each  packet  rather  than  the
              default  of 65535 bytes.  Packets truncated because of a limited
              snapshot are indicated in the output  with  ``[|_p_r_o_t_o]'',  where
              _p_r_o_t_o  is the name of the protocol level at which the truncation
              has occurred.  Note that taking larger snapshots both  increases
              the amount of time it takes to process packets and, effectively,
              decreases the amount of packet buffering.  This may cause  pack-
              ets to be lost.  You should limit _s_n_a_p_l_e_n to the smallest number
              that will capture the protocol information you're interested in.
              Setting  _s_n_a_p_l_e_n to 0 sets it to the default of 65535, for back-
              wards compatibility with recent older versions of _t_c_p_d_u_m_p.

       --TT     Force packets selected by "_e_x_p_r_e_s_s_i_o_n"  to  be  interpreted  the
              specified  _t_y_p_e.   Currently  known  types  are aaooddvv (Ad-hoc On-
              demand Distance Vector protocol), ccaarrpp  (Common  Address  Redun-
              dancy Protocol), ccnnffpp (Cisco NetFlow protocol), rraaddiiuuss (RADIUS),
              rrppcc (Remote Procedure Call), rrttpp (Real-Time Applications  proto-
              col), rrttccpp (Real-Time Applications control protocol), ssnnmmpp (Sim-
              ple Network Management Protocol), ttffttpp  (Trivial  File  Transfer
              Protocol),  vvaatt  (Visual  Audio  Tool),  wwbb  (distributed  White
              Board), zzmmttpp11 (ZeroMQ Message Transport Protocol 1.0) and  vvxxllaann
              (Virtual eXtensible Local Area Network).

       --tt     _D_o_n_'_t print a timestamp on each dump line.

       --tttt    Print an unformatted timestamp on each dump line.

       --tttttt   Print a delta (micro-second resolution) between current and pre-
              vious line on each dump line.

       --tttttttt  Print a timestamp in default format proceeded by  date  on  each
              dump line.

       --tttttttttt Print  a  delta  (micro-second  resolution)  between current and
              first line on each dump line.

       --tt nn   An alternate form for specifying the kind of  timestamp  display
              where nn is a number between 0 and 5 with the following meaning:

                     00     time
                     11     no time
                     22     unformatted timestamp
                     33     microseconds since previous line
                     44     date and time
                     55     microseconds since first line

              This option may be specified more than once to display more than
              one kind of timestamp on each dump line.

       --uu     Print undecoded NFS handles.

       --UU     If the --ww option is not specified, make the printed packet  out-
              put  ``packet-buffered'';  i.e.,  as the description of the con-
              tents of each packet is printed, it will be written to the stan-
              dard  output, rather than, when not writing to a terminal, being
              written only when the output buffer fills.

              If the --ww option is specified, make the saved raw packet  output
              ``packet-buffered'';  i.e.,  as each packet is saved, it will be
              written to the output file, rather than being written only  when
              the output buffer fills.

              The  --UU  flag will not be supported if _t_c_p_d_u_m_p was built with an
              older version of _l_i_b_p_c_a_p that lacks the ppccaapp__dduummpp__fflluusshh(())  func-
              tion.

       --vv     When  parsing and printing, produce (slightly more) verbose out-
              put.  For example,  the  time  to  live,  identification,  total
              length  and  options  in an IP packet are printed.  Also enables
              additional packet integrity checks such as verifying the IP  and
              ICMP header checksum.

              When writing to a file with the --ww option, report, every 10 sec-
              onds, the number of packets captured.

       --vvvv    Even more verbose output.  For example,  additional  fields  are
              printed  from  NFS  reply  packets,  and  SMB  packets are fully
              decoded.

       --vvvvvv   Even more verbose output.  For example, telnet SSBB ... SSEE options
              are  printed in full.  With --XX Telnet options are printed in hex
              as well.

       --VV     Read a list of filenames from _f_i_l_e. Standard input  is  used  if
              _f_i_l_e is ``-''.

       --ww     Write  the  raw packets to _f_i_l_e rather than parsing and printing
              them out.  They can later be printed with the -r option.   Stan-
              dard output is used if _f_i_l_e is ``-''.

              This  output will be buffered if written to a file or pipe, so a
              program reading from the file or pipe may not see packets for an
              arbitrary  amount  of  time after they are received.  Use the --UU
              flag to cause  packets  to  be  written  as  soon  as  they  are
              received.

              The  MIME  type _a_p_p_l_i_c_a_t_i_o_n_/_v_n_d_._t_c_p_d_u_m_p_._p_c_a_p has been registered
              with IANA for _p_c_a_p files. The filename extension  _._p_c_a_p  appears
              to  be  the most commonly used along with _._c_a_p and _._d_m_p. _T_c_p_d_u_m_p
              itself doesn't check the extension when  reading  capture  files
              and  doesn't  add  an extension when writing them (it uses magic
              numbers in the file header  instead).  However,  many  operating
              systems and applications will use the extension if it is present
              and adding one (e.g. .pcap) is recommended.

              See ppccaapp--ssaavveeffiillee(5) for a description of the file format.

       --WW     Used in conjunction with the --CC option, this will limit the num-
              ber  of  files  created to the specified number, and begin over-
              writing files from the beginning,  thus  creating  a  'rotating'
              buffer.  In addition, it will name the files with enough leading
              0s to support the maximum number of files, allowing them to sort
              correctly.

              Used in conjunction with the --GG option, this will limit the num-
              ber of rotated dump files that get created, exiting with  status
              0 when reaching the limit. If used with --CC as well, the behavior
              will result in cyclical files per timeslice.

       --xx     When parsing and printing, in addition to printing  the  headers
              of  each  packet,  print the data of each packet (minus its link
              level header) in hex.  The  smaller  of  the  entire  packet  or
              _s_n_a_p_l_e_n  bytes  will  be  printed.  Note that this is the entire
              link-layer packet, so for link layers that pad (e.g.  Ethernet),
              the  padding  bytes  will  also be printed when the higher layer
              packet is shorter than the required padding.

       --xxxx    When parsing and printing, in addition to printing  the  headers
              of  each  packet,  print  the data of each packet, _i_n_c_l_u_d_i_n_g its
              link level header, in hex.

       --XX     When parsing and printing, in addition to printing  the  headers
              of  each  packet,  print the data of each packet (minus its link
              level header)  in  hex  and  ASCII.   This  is  very  handy  for
              analysing new protocols.

       --XXXX    When  parsing  and printing, in addition to printing the headers
              of each packet, print the data of  each  packet,  _i_n_c_l_u_d_i_n_g  its
              link level header, in hex and ASCII.

       --yy     Set  the  data  link  type  to  use  while  capturing packets to
              _d_a_t_a_l_i_n_k_t_y_p_e.

       --zz     Used in conjunction with the --CC or --GG options,  this  will  make
              _t_c_p_d_u_m_p  run  "  _c_o_m_m_a_n_d _f_i_l_e " where _f_i_l_e is the savefile being
              closed after each rotation. For example, specifying --zz  ggzziipp  or
              --zz bbzziipp22 will compress each savefile using gzip or bzip2.

              Note  that  tcpdump will run the command in parallel to the cap-
              ture, using the lowest priority so that this doesn't disturb the
              capture process.

              And  in  case  you would like to use a command that itself takes
              flags or different arguments,  you  can  always  write  a  shell
              script  that  will  take the savefile name as the only argument,
              make the flags & arguments arrangements and execute the  command
              that you want.

       --ZZ     If  _t_c_p_d_u_m_p is running as root, after opening the capture device
              or input savefile, but before opening any savefiles for  output,
              change the user ID to _u_s_e_r and the group ID to the primary group
              of _u_s_e_r.

              This behavior can also be enabled by default at compile time.

        _e_x_p_r_e_s_s_i_o_n
              selects which packets will  be  dumped.   If  no  _e_x_p_r_e_s_s_i_o_n  is
              given,  all  packets on the net will be dumped.  Otherwise, only
              packets for which _e_x_p_r_e_s_s_i_o_n is `true' will be dumped.

              For the _e_x_p_r_e_s_s_i_o_n syntax, see ppccaapp--ffiilltteerr(7).

              Expression arguments can be passed to _t_c_p_d_u_m_p as either a single
              argument or as multiple arguments, whichever is more convenient.
              Generally, if the expression contains Shell metacharacters, such
              as  backslashes  used  to escape protocol names, it is easier to
              pass it as a single, quoted argument rather than to  escape  the
              Shell  metacharacters.  Multiple arguments are concatenated with
              spaces before being parsed.

EEXXAAMMPPLLEESS
       To print all packets arriving at or departing from _s_u_n_d_o_w_n:
              ttccppdduummpp hhoosstt ssuunnddoowwnn

       To print traffic between _h_e_l_i_o_s and either _h_o_t or _a_c_e:
              ttccppdduummpp hhoosstt hheelliiooss aanndd \\(( hhoott oorr aaccee \\))

       To print all IP packets between _a_c_e and any host except _h_e_l_i_o_s:
              ttccppdduummpp iipp hhoosstt aaccee aanndd nnoott hheelliiooss

       To print all traffic between local hosts and hosts at Berkeley:
              ttccppdduummpp nneett uuccbb--eetthheerr

       To print all ftp traffic through internet gateway _s_n_u_p: (note that  the
       expression  is  quoted to prevent the shell from (mis-)interpreting the
       parentheses):
              ttccppdduummpp ''ggaatteewwaayy ssnnuupp aanndd ((ppoorrtt ffttpp oorr ffttpp--ddaattaa))''

       To print traffic neither sourced from nor destined for local hosts  (if
       you gateway to one other net, this stuff should never make it onto your
       local net).
              ttccppdduummpp iipp aanndd nnoott nneett _l_o_c_a_l_n_e_t

       To print the start and end packets (the SYN and FIN  packets)  of  each
       TCP conversation that involves a non-local host.
              ttccppdduummpp ''ttccpp[[ttccppffllaaggss]] && ((ttccpp--ssyynn||ttccpp--ffiinn)) !!== 00 aanndd nnoott ssrrcc aanndd ddsstt nneett _l_o_c_a_l_n_e_t''

       To  print  all  IPv4  HTTP packets to and from port 80, i.e. print only
       packets that contain data, not, for example, SYN and  FIN  packets  and
       ACK-only packets.  (IPv6 is left as an exercise for the reader.)
              ttccppdduummpp ''ttccpp ppoorrtt 8800 aanndd ((((((iipp[[22::22]] -- ((((iipp[[00]]&&00xxff))<<<<22)))) -- ((((ttccpp[[1122]]&&00xxff00))>>>>22)))) !!== 00))''

       To print IP packets longer than 576 bytes sent through gateway _s_n_u_p:
              ttccppdduummpp ''ggaatteewwaayy ssnnuupp aanndd iipp[[22::22]] >> 557766''

       To  print IP broadcast or multicast packets that were _n_o_t sent via Eth-
       ernet broadcast or multicast:
              ttccppdduummpp ''eetthheerr[[00]] && 11 == 00 aanndd iipp[[1166]] >>== 222244''

       To print all ICMP packets that are not echo requests/replies (i.e., not
       ping packets):
              ttccppdduummpp ''iiccmmpp[[iiccmmppttyyppee]] !!== iiccmmpp--eecchhoo aanndd iiccmmpp[[iiccmmppttyyppee]] !!== iiccmmpp--eecchhoorreeppllyy''

OOUUTTPPUUTT FFOORRMMAATT
       The  output  of  _t_c_p_d_u_m_p  is protocol dependent.  The following gives a
       brief description and examples of most of the formats.

       LLiinnkk LLeevveell HHeeaaddeerrss

       If the '-e' option is given, the link level header is printed out.   On
       Ethernets,  the  source and destination addresses, protocol, and packet
       length are printed.

       On FDDI networks, the  '-e' option causes _t_c_p_d_u_m_p to print  the  `frame
       control'  field,   the source and destination addresses, and the packet
       length.  (The `frame control' field governs the interpretation  of  the
       rest  of the packet.  Normal packets (such as those containing IP data-
       grams) are `async' packets, with a priority value between 0 and 7;  for
       example,  `aassyynncc44'.  Such packets are assumed to contain an 802.2 Logi-
       cal Link Control (LLC) packet; the LLC header is printed if it  is  _n_o_t
       an ISO datagram or a so-called SNAP packet.

       On  Token  Ring  networks,  the '-e' option causes _t_c_p_d_u_m_p to print the
       `access control' and `frame control' fields, the source and destination
       addresses,  and  the  packet  length.  As on FDDI networks, packets are
       assumed to contain an LLC  packet.   Regardless  of  whether  the  '-e'
       option  is  specified or not, the source routing information is printed
       for source-routed packets.

       On 802.11 networks, the '-e' option causes _t_c_p_d_u_m_p to print the  `frame
       control'  fields,  all  of  the addresses in the 802.11 header, and the
       packet length.  As on FDDI networks, packets are assumed to contain  an
       LLC packet.

       _(_N_._B_._: _T_h_e _f_o_l_l_o_w_i_n_g _d_e_s_c_r_i_p_t_i_o_n _a_s_s_u_m_e_s _f_a_m_i_l_i_a_r_i_t_y _w_i_t_h _t_h_e _S_L_I_P _c_o_m_-
       _p_r_e_s_s_i_o_n _a_l_g_o_r_i_t_h_m _d_e_s_c_r_i_b_e_d _i_n _R_F_C_-_1_1_4_4_._)

       On SLIP links, a direction indicator (``I'' for inbound, ``O'' for out-
       bound),  packet type, and compression information are printed out.  The
       packet type is printed first.  The three types are _i_p, _u_t_c_p, and  _c_t_c_p.
       No  further  link information is printed for _i_p packets.  For TCP pack-
       ets, the connection identifier is printed following the type.   If  the
       packet  is  compressed, its encoded header is printed out.  The special
       cases are printed out as **SS++_n and **SSAA++_n, where _n is the amount by which
       the sequence number (or sequence number and ack) has changed.  If it is
       not a special case, zero or more changes  are  printed.   A  change  is
       indicated  by U (urgent pointer), W (window), A (ack), S (sequence num-
       ber), and I (packet ID), followed by a delta (+n or -n), or a new value
       (=n).   Finally, the amount of data in the packet and compressed header
       length are printed.

       For example, the  following  line  shows  an  outbound  compressed  TCP
       packet,  with an implicit connection identifier; the ack has changed by
       6, the sequence number by 49, and the packet ID by 6; there are 3 bytes
       of data and 6 bytes of compressed header:
              OO ccttccpp ** AA++66 SS++4499 II++66 33 ((66))

       AARRPP//RRAARRPP PPaacckkeettss

       Arp/rarp  output shows the type of request and its arguments.  The for-
       mat is intended to be self explanatory.  Here is a short  sample  taken
       from the start of an `rlogin' from host _r_t_s_g to host _c_s_a_m:
              arp who-has csam tell rtsg
              arp reply csam is-at CSAM
       The  first line says that rtsg sent an arp packet asking for the Ether-
       net address of internet host csam.   Csam  replies  with  its  Ethernet
       address  (in  this example, Ethernet addresses are in caps and internet
       addresses in lower case).

       This would look less redundant if we had done _t_c_p_d_u_m_p _-_n:
              arp who-has 128.3.254.6 tell 128.3.254.68
              arp reply 128.3.254.6 is-at 02:07:01:00:01:c4

       If we had done _t_c_p_d_u_m_p _-_e, the fact that the first packet is  broadcast
       and the second is point-to-point would be visible:
              RTSG Broadcast 0806  64: arp who-has csam tell rtsg
              CSAM RTSG 0806  64: arp reply csam is-at CSAM
       For the first packet this says the Ethernet source address is RTSG, the
       destination is the Ethernet broadcast address, the type field contained
       hex 0806 (type ETHER_ARP) and the total length was 64 bytes.

       TTCCPP PPaacckkeettss

       _(_N_._B_._:_T_h_e _f_o_l_l_o_w_i_n_g _d_e_s_c_r_i_p_t_i_o_n _a_s_s_u_m_e_s _f_a_m_i_l_i_a_r_i_t_y _w_i_t_h _t_h_e _T_C_P _p_r_o_t_o_-
       _c_o_l _d_e_s_c_r_i_b_e_d _i_n _R_F_C_-_7_9_3_.  _I_f _y_o_u _a_r_e _n_o_t _f_a_m_i_l_i_a_r _w_i_t_h  _t_h_e  _p_r_o_t_o_c_o_l_,
       _n_e_i_t_h_e_r _t_h_i_s _d_e_s_c_r_i_p_t_i_o_n _n_o_r _t_c_p_d_u_m_p _w_i_l_l _b_e _o_f _m_u_c_h _u_s_e _t_o _y_o_u_._)

       The general format of a tcp protocol line is:
              _s_r_c _> _d_s_t_: _f_l_a_g_s _d_a_t_a_-_s_e_q_n_o _a_c_k _w_i_n_d_o_w _u_r_g_e_n_t _o_p_t_i_o_n_s
       _S_r_c  and  _d_s_t  are  the  source and destination IP addresses and ports.
       _F_l_a_g_s are some combination of S (SYN), F (FIN), P (PUSH),  R  (RST),  U
       (URG),  W  (ECN  CWR), E (ECN-Echo) or `.' (ACK), or `none' if no flags
       are set.  _D_a_t_a_-_s_e_q_n_o describes the portion of sequence space covered by
       the data in this packet (see example below).  _A_c_k is sequence number of
       the next data expected the other direction on this connection.   _W_i_n_d_o_w
       is  the  number  of  bytes  of receive buffer space available the other
       direction on this connection.  _U_r_g indicates there is `urgent' data  in
       the  packet.  _O_p_t_i_o_n_s are tcp options enclosed in angle brackets (e.g.,
       <mss 1024>).

       _S_r_c_, _d_s_t and _f_l_a_g_s are always present.  The other fields depend on  the
       contents  of  the  packet's  tcp protocol header and are output only if
       appropriate.

       Here is the opening portion of an rlogin from host _r_t_s_g to host _c_s_a_m.
              rtsg.1023 > csam.login: S 768512:768512(0) win 4096 <mss 1024>
              csam.login > rtsg.1023: S 947648:947648(0) ack 768513 win 4096 <mss 1024>
              rtsg.1023 > csam.login: . ack 1 win 4096
              rtsg.1023 > csam.login: P 1:2(1) ack 1 win 4096
              csam.login > rtsg.1023: . ack 2 win 4096
              rtsg.1023 > csam.login: P 2:21(19) ack 1 win 4096
              csam.login > rtsg.1023: P 1:2(1) ack 21 win 4077
              csam.login > rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1
              csam.login > rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1
       The first line says that tcp port 1023 on rtsg sent a  packet  to  port
       _l_o_g_i_n  on csam.  The SS indicates that the _S_Y_N flag was set.  The packet
       sequence number was 768512 and it contained no data.  (The notation  is
       `first:last(nbytes)'  which means `sequence numbers _f_i_r_s_t up to but not
       including _l_a_s_t which is _n_b_y_t_e_s bytes of  user  data'.)   There  was  no
       piggy-backed ack, the available receive window was 4096 bytes and there
       was a max-segment-size option requesting an mss of 1024 bytes.

       Csam replies with a similar packet except it  includes  a  piggy-backed
       ack  for rtsg's SYN.  Rtsg then acks csam's SYN.  The `.' means the ACK
       flag was set.  The packet  contained  no  data  so  there  is  no  data
       sequence  number.  Note that the ack sequence number is a small integer
       (1).  The first time _t_c_p_d_u_m_p sees a tcp `conversation', it  prints  the
       sequence  number from the packet.  On subsequent packets of the conver-
       sation, the difference between the current packet's sequence number and
       this initial sequence number is printed.  This means that sequence num-
       bers after the first can be interpreted as relative byte  positions  in
       the conversation's data stream (with the first data byte each direction
       being `1').  `-S' will override  this  feature,  causing  the  original
       sequence numbers to be output.

       On  the  6th line, rtsg sends csam 19 bytes of data (bytes 2 through 20
       in the rtsg -> csam side of the conversation).  The PUSH flag is set in
       the packet.  On the 7th line, csam says it's received data sent by rtsg
       up to but not including byte 21.  Most of this data is apparently  sit-
       ting  in  the  socket  buffer since csam's receive window has gotten 19
       bytes smaller.  Csam also sends one  byte  of  data  to  rtsg  in  this
       packet.   On  the  8th  and  9th lines, csam sends two bytes of urgent,
       pushed data to rtsg.

       If the snapshot was small enough that _t_c_p_d_u_m_p didn't capture  the  full
       TCP  header,  it  interprets  as  much of the header as it can and then
       reports ``[|_t_c_p]'' to indicate the remainder could not be  interpreted.
       If  the header contains a bogus option (one with a length that's either
       too small or beyond the end of  the  header),  _t_c_p_d_u_m_p  reports  it  as
       ``[_b_a_d  _o_p_t]''  and  does not interpret any further options (since it's
       impossible to tell where they start).  If the header  length  indicates
       options  are  present but the IP datagram length is not long enough for
       the options to actually be there, _t_c_p_d_u_m_p  reports  it  as  ``[_b_a_d  _h_d_r
       _l_e_n_g_t_h]''.

       CCaappttuurriinngg  TTCCPP ppaacckkeettss wwiitthh ppaarrttiiccuullaarr ffllaagg ccoommbbiinnaattiioonnss ((SSYYNN--AACCKK,, UURRGG--
       AACCKK,, eettcc..))

       There are 8 bits in the control bits section of the TCP header:

              _C_W_R _| _E_C_E _| _U_R_G _| _A_C_K _| _P_S_H _| _R_S_T _| _S_Y_N _| _F_I_N

       Let's assume that we want to watch packets used in establishing  a  TCP
       connection.   Recall  that  TCP uses a 3-way handshake protocol when it
       initializes a new connection; the connection sequence  with  regard  to
       the TCP control bits is

              1) Caller sends SYN
              2) Recipient responds with SYN, ACK
              3) Caller sends ACK

       Now  we're  interested  in capturing packets that have only the SYN bit
       set (Step 1).  Note that we don't want packets from step  2  (SYN-ACK),
       just  a plain initial SYN.  What we need is a correct filter expression
       for _t_c_p_d_u_m_p.

       Recall the structure of a TCP header without options:

        0                            15                              31
       -----------------------------------------------------------------
       |          source port          |       destination port        |
       -----------------------------------------------------------------
       |                        sequence number                        |
       -----------------------------------------------------------------
       |                     acknowledgment number                     |
       -----------------------------------------------------------------
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       -----------------------------------------------------------------
       |         TCP checksum          |       urgent pointer          |
       -----------------------------------------------------------------

       A TCP header usually holds  20  octets  of  data,  unless  options  are
       present.  The first line of the graph contains octets 0 - 3, the second
       line shows octets 4 - 7 etc.

       Starting to count with 0, the relevant TCP control bits  are  contained
       in octet 13:

        0             7|             15|             23|             31
       ----------------|---------------|---------------|----------------
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       ----------------|---------------|---------------|----------------
       |               |  13th octet   |               |               |

       Let's have a closer look at octet no. 13:

                       |               |
                       |---------------|
                       |C|E|U|A|P|R|S|F|
                       |---------------|
                       |7   5   3     0|

       These  are the TCP control bits we are interested in.  We have numbered
       the bits in this octet from 0 to 7, right to left, so the  PSH  bit  is
       bit number 3, while the URG bit is number 5.

       Recall  that  we  want to capture packets with only SYN set.  Let's see
       what happens to octet 13 if a TCP datagram arrives with the SYN bit set
       in its header:

                       |C|E|U|A|P|R|S|F|
                       |---------------|
                       |0 0 0 0 0 0 1 0|
                       |---------------|
                       |7 6 5 4 3 2 1 0|

       Looking at the control bits section we see that only bit number 1 (SYN)
       is set.

       Assuming that octet number 13 is an 8-bit unsigned integer  in  network
       byte order, the binary value of this octet is

              00000010

       and its decimal representation is

          7     6     5     4     3     2     1     0
       0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 1*2 + 0*2  =  2

       We're  almost  done,  because  now we know that if only SYN is set, the
       value of the 13th octet in the TCP header, when interpreted as a  8-bit
       unsigned integer in network byte order, must be exactly 2.

       This relationship can be expressed as
              ttccpp[[1133]] ==== 22

       We  can use this expression as the filter for _t_c_p_d_u_m_p in order to watch
       packets which have only SYN set:
              ttccppdduummpp --ii xxll00 ttccpp[[1133]] ==== 22

       The expression says "let the 13th octet of a TCP datagram have the dec-
       imal value 2", which is exactly what we want.

       Now,  let's  assume  that  we need to capture SYN packets, but we don't
       care if ACK or any other TCP control bit  is  set  at  the  same  time.
       Let's see what happens to octet 13 when a TCP datagram with SYN-ACK set
       arrives:

            |C|E|U|A|P|R|S|F|
            |---------------|
            |0 0 0 1 0 0 1 0|
            |---------------|
            |7 6 5 4 3 2 1 0|

       Now bits 1 and 4 are set in the 13th octet.  The binary value of  octet
       13 is

                   00010010

       which translates to decimal

          7     6     5     4     3     2     1     0
       0*2 + 0*2 + 0*2 + 1*2 + 0*2 + 0*2 + 1*2 + 0*2   = 18

       Now we can't just use 'tcp[13] == 18' in the _t_c_p_d_u_m_p filter expression,
       because that would select only those packets that have SYN-ACK set, but
       not those with only SYN set.  Remember that we don't care if ACK or any
       other control bit is set as long as SYN is set.

       In order to achieve our goal, we need to logically AND the binary value
       of  octet  13  with  some other value to preserve the SYN bit.  We know
       that we want SYN to be set in any case,  so  we'll  logically  AND  the
       value in the 13th octet with the binary value of a SYN:


                 00010010 SYN-ACK              00000010 SYN
            AND  00000010 (we want SYN)   AND  00000010 (we want SYN)
                 --------                      --------
            =    00000010                 =    00000010

       We  see  that  this  AND  operation delivers the same result regardless
       whether ACK or another TCP control bit is set.  The decimal representa-
       tion  of  the  AND  value  as well as the result of this operation is 2
       (binary 00000010), so we know that for packets with SYN set the follow-
       ing relation must hold true:

              ( ( value of octet 13 ) AND ( 2 ) ) == ( 2 )

       This points us to the _t_c_p_d_u_m_p filter expression
                   ttccppdduummpp --ii xxll00 ''ttccpp[[1133]] && 22 ==== 22''

       Some  offsets and field values may be expressed as names rather than as
       numeric values. For example tcp[13] may be replaced with tcp[tcpflags].
       The  following  TCP flag field values are also available: tcp-fin, tcp-
       syn, tcp-rst, tcp-push, tcp-act, tcp-urg.

       This can be demonstrated as:
                   ttccppdduummpp --ii xxll00 ''ttccpp[[ttccppffllaaggss]] && ttccpp--ppuusshh !!== 00''

       Note that you should use single quotes or a backslash in the expression
       to hide the AND ('&') special character from the shell.

       UUDDPP PPaacckkeettss

       UDP format is illustrated by this rwho packet:
              actinide.who > broadcast.who: udp 84
       This  says  that  port _w_h_o on host _a_c_t_i_n_i_d_e sent a udp datagram to port
       _w_h_o on host _b_r_o_a_d_c_a_s_t, the Internet broadcast address.  The packet con-
       tained 84 bytes of user data.

       Some  UDP  services are recognized (from the source or destination port
       number) and the higher level protocol information printed.  In particu-
       lar,  Domain  Name  service  requests (RFC-1034/1035) and Sun RPC calls
       (RFC-1050) to NFS.

       UUDDPP NNaammee SSeerrvveerr RReeqquueessttss

       _(_N_._B_._:_T_h_e _f_o_l_l_o_w_i_n_g _d_e_s_c_r_i_p_t_i_o_n _a_s_s_u_m_e_s  _f_a_m_i_l_i_a_r_i_t_y  _w_i_t_h  _t_h_e  _D_o_m_a_i_n
       _S_e_r_v_i_c_e  _p_r_o_t_o_c_o_l  _d_e_s_c_r_i_b_e_d _i_n _R_F_C_-_1_0_3_5_.  _I_f _y_o_u _a_r_e _n_o_t _f_a_m_i_l_i_a_r _w_i_t_h
       _t_h_e _p_r_o_t_o_c_o_l_, _t_h_e _f_o_l_l_o_w_i_n_g _d_e_s_c_r_i_p_t_i_o_n _w_i_l_l _a_p_p_e_a_r _t_o  _b_e  _w_r_i_t_t_e_n  _i_n
       _g_r_e_e_k_._)

       Name server requests are formatted as
              _s_r_c _> _d_s_t_: _i_d _o_p_? _f_l_a_g_s _q_t_y_p_e _q_c_l_a_s_s _n_a_m_e _(_l_e_n_)
              h2opolo.1538 > helios.domain: 3+ A? ucbvax.berkeley.edu. (37)
       Host  _h_2_o_p_o_l_o  asked  the domain server on _h_e_l_i_o_s for an address record
       (qtype=A) associated with the name _u_c_b_v_a_x_._b_e_r_k_e_l_e_y_._e_d_u_.  The  query  id
       was  `3'.   The  `+' indicates the _r_e_c_u_r_s_i_o_n _d_e_s_i_r_e_d flag was set.  The
       query length was 37 bytes, not including the UDP and IP protocol  head-
       ers.   The  query  operation was the normal one, _Q_u_e_r_y, so the op field
       was omitted.  If the op had been anything  else,  it  would  have  been
       printed  between  the  `3'  and the `+'.  Similarly, the qclass was the
       normal one, _C___I_N, and  omitted.   Any  other  qclass  would  have  been
       printed immediately after the `A'.

       A  few anomalies are checked and may result in extra fields enclosed in
       square brackets:  If a query contains an answer, authority  records  or
       additional records section, _a_n_c_o_u_n_t, _n_s_c_o_u_n_t, or _a_r_c_o_u_n_t are printed as
       `[_na]', `[_nn]' or  `[_nau]' where _n is the appropriate count.  If any of
       the  response  bits  are  set  (AA, RA or rcode) or any of the `must be
       zero' bits are set in bytes two and three, `[b2&3=_x]' is printed, where
       _x is the hex value of header bytes two and three.

       UUDDPP NNaammee SSeerrvveerr RReessppoonnsseess

       Name server responses are formatted as
              _s_r_c _> _d_s_t_:  _i_d _o_p _r_c_o_d_e _f_l_a_g_s _a_/_n_/_a_u _t_y_p_e _c_l_a_s_s _d_a_t_a _(_l_e_n_)
              helios.domain > h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)
              helios.domain > h2opolo.1537: 2 NXDomain* 0/1/0 (97)
       In the first example, _h_e_l_i_o_s responds to query id 3 from _h_2_o_p_o_l_o with 3
       answer records, 3 name server records and 7  additional  records.   The
       first  answer  record  is  type  A  (address)  and its data is internet
       address 128.32.137.3.  The total size of the response  was  273  bytes,
       excluding  UDP and IP headers.  The op (Query) and response code (NoEr-
       ror) were omitted, as was the class (C_IN) of the A record.

       In the second example, _h_e_l_i_o_s responds to query 2 with a response  code
       of  non-existent domain (NXDomain) with no answers, one name server and
       no authority records.  The `*' indicates that the _a_u_t_h_o_r_i_t_a_t_i_v_e  _a_n_s_w_e_r
       bit  was set.  Since there were no answers, no type, class or data were
       printed.

       Other flag characters that might appear are `-'  (recursion  available,
       RA,  _n_o_t  set) and `|' (truncated message, TC, set).  If the `question'
       section doesn't contain exactly one entry, `[_nq]' is printed.

       SSMMBB//CCIIFFSS ddeeccooddiinngg

       _t_c_p_d_u_m_p now includes fairly extensive SMB/CIFS/NBT decoding for data on
       UDP/137,  UDP/138 and TCP/139.  Some primitive decoding of IPX and Net-
       BEUI SMB data is also done.

       By default a fairly minimal decode is done, with a much  more  detailed
       decode  done if -v is used.  Be warned that with -v a single SMB packet
       may take up a page or more, so only use -v if you really want  all  the
       gory details.

       For  information on SMB packet formats and what all the fields mean see
       www.cifs.org  or  the  pub/samba/specs/  directory  on  your   favorite
       samba.org mirror site.  The SMB patches were written by Andrew Tridgell
       (tridge@samba.org).

       NNFFSS RReeqquueessttss aanndd RReepplliieess

       Sun NFS (Network File System) requests and replies are printed as:
              _s_r_c_._x_i_d _> _d_s_t_._n_f_s_: _l_e_n _o_p _a_r_g_s
              _s_r_c_._n_f_s _> _d_s_t_._x_i_d_: _r_e_p_l_y _s_t_a_t _l_e_n _o_p _r_e_s_u_l_t_s
              sushi.6709 > wrl.nfs: 112 readlink fh 21,24/10.73165
              wrl.nfs > sushi.6709: reply ok 40 readlink "../var"
              sushi.201b > wrl.nfs:
                   144 lookup fh 9,74/4096.6878 "xcolors"
              wrl.nfs > sushi.201b:
                   reply ok 128 lookup fh 9,74/4134.3150
       In the first line, host _s_u_s_h_i sends a transaction with id _6_7_0_9  to  _w_r_l
       (note  that  the number following the src host is a transaction id, _n_o_t
       the source port).  The request was 112 bytes, excluding the UDP and  IP
       headers.   The  operation  was  a _r_e_a_d_l_i_n_k (read symbolic link) on file
       handle (_f_h) 21,24/10.731657119.  (If one is lucky, as in this case, the
       file  handle  can  be  interpreted as a major,minor device number pair,
       followed by the inode number and generation number.)  _W_r_l replies  `ok'
       with the contents of the link.

       In  the  third  line,  _s_u_s_h_i  asks  _w_r_l to lookup the name `_x_c_o_l_o_r_s' in
       directory file 9,74/4096.6878.  Note that the data printed  depends  on
       the  operation  type.  The format is intended to be self explanatory if
       read in conjunction with an NFS protocol spec.

       If the -v (verbose) flag is given, additional information  is  printed.
       For example:
              sushi.1372a > wrl.nfs:
                   148 read fh 21,11/12.195 8192 bytes @ 24576
              wrl.nfs > sushi.1372a:
                   reply ok 1472 read REG 100664 ids 417/0 sz 29388
       (-v  also  prints  the  IP  header  TTL,  ID, length, and fragmentation
       fields, which have been omitted from this example.)  In the first line,
       _s_u_s_h_i  asks _w_r_l to read 8192 bytes from file 21,11/12.195, at byte off-
       set 24576.  _W_r_l replies `ok'; the packet shown on the  second  line  is
       the first fragment of the reply, and hence is only 1472 bytes long (the
       other bytes will follow in subsequent fragments, but these fragments do
       not have NFS or even UDP headers and so might not be printed, depending
       on the filter expression used).  Because the -v flag is given, some  of
       the  file  attributes (which are returned in addition to the file data)
       are printed: the file type (``REG'', for regular file), the  file  mode
       (in octal), the uid and gid, and the file size.

       If  the -v flag is given more than once, even more details are printed.

       Note that NFS requests are very large and much of the detail  won't  be
       printed  unless  _s_n_a_p_l_e_n is increased.  Try using `--ss 119922' to watch NFS
       traffic.

       NFS reply  packets  do  not  explicitly  identify  the  RPC  operation.
       Instead,  _t_c_p_d_u_m_p  keeps track of ``recent'' requests, and matches them
       to the replies using the transaction ID.  If a reply does  not  closely
       follow the corresponding request, it might not be parsable.

       AAFFSS RReeqquueessttss aanndd RReepplliieess

       Transarc AFS (Andrew File System) requests and replies are printed as:

              _s_r_c_._s_p_o_r_t _> _d_s_t_._d_p_o_r_t_: _r_x _p_a_c_k_e_t_-_t_y_p_e
              _s_r_c_._s_p_o_r_t _> _d_s_t_._d_p_o_r_t_: _r_x _p_a_c_k_e_t_-_t_y_p_e _s_e_r_v_i_c_e _c_a_l_l _c_a_l_l_-_n_a_m_e _a_r_g_s
              _s_r_c_._s_p_o_r_t _> _d_s_t_._d_p_o_r_t_: _r_x _p_a_c_k_e_t_-_t_y_p_e _s_e_r_v_i_c_e _r_e_p_l_y _c_a_l_l_-_n_a_m_e _a_r_g_s
              elvis.7001 > pike.afsfs:
                   rx data fs call rename old fid 536876964/1/1 ".newsrc.new"
                   new fid 536876964/1/1 ".newsrc"
              pike.afsfs > elvis.7001: rx data fs reply rename
       In the first line, host elvis sends a RX packet to pike.  This was a RX
       data packet to the fs (fileserver) service, and is the start of an  RPC
       call.   The  RPC  call  was a rename, with the old directory file id of
       536876964/1/1 and an old filename of `.newsrc.new', and a new directory
       file  id  of  536876964/1/1  and a new filename of `.newsrc'.  The host
       pike responds with a RPC reply to the rename call (which  was  success-
       ful, because it was a data packet and not an abort packet).

       In  general,  all AFS RPCs are decoded at least by RPC call name.  Most
       AFS RPCs have at least some of the arguments  decoded  (generally  only
       the `interesting' arguments, for some definition of interesting).

       The  format is intended to be self-describing, but it will probably not
       be useful to people who are not familiar with the workings of  AFS  and
       RX.

       If  the  -v  (verbose) flag is given twice, acknowledgement packets and
       additional header information is printed, such as the RX call ID,  call
       number, sequence number, serial number, and the RX packet flags.

       If  the -v flag is given twice, additional information is printed, such
       as the RX call ID, serial number, and the RX  packet  flags.   The  MTU
       negotiation information is also printed from RX ack packets.

       If  the -v flag is given three times, the security index and service id
       are printed.

       Error codes are printed for abort packets, with the exception  of  Ubik
       beacon  packets  (because  abort packets are used to signify a yes vote
       for the Ubik protocol).

       Note that AFS requests are very large and many of the  arguments  won't
       be  printed  unless  _s_n_a_p_l_e_n is increased.  Try using `--ss 225566' to watch
       AFS traffic.

       AFS reply  packets  do  not  explicitly  identify  the  RPC  operation.
       Instead,  _t_c_p_d_u_m_p  keeps track of ``recent'' requests, and matches them
       to the replies using the call number and service ID.  If a  reply  does
       not closely follow the corresponding request, it might not be parsable.


       KKIIPP AApppplleeTTaallkk ((DDDDPP iinn UUDDPP))

       AppleTalk DDP packets encapsulated in UDP datagrams are de-encapsulated
       and dumped as DDP packets (i.e., all the UDP header information is dis-
       carded).  The file _/_e_t_c_/_a_t_a_l_k_._n_a_m_e_s is used to translate AppleTalk  net
       and node numbers to names.  Lines in this file have the form
              _n_u_m_b_e_r    _n_a_m_e

              1.254          ether
              16.1      icsd-net
              1.254.110 ace
       The  first  two  lines give the names of AppleTalk networks.  The third
       line gives the name of a particular host (a host is distinguished  from
       a  net  by  the  3rd  octet  in the number - a net number _m_u_s_t have two
       octets and a host number _m_u_s_t have three octets.)  The number and  name
       should   be   separated   by   whitespace   (blanks   or   tabs).   The
       _/_e_t_c_/_a_t_a_l_k_._n_a_m_e_s file may contain blank lines or comment  lines  (lines
       starting with a `#').

       AppleTalk addresses are printed in the form
              _n_e_t_._h_o_s_t_._p_o_r_t

              144.1.209.2 > icsd-net.112.220
              office.2 > icsd-net.112.220
              jssmag.149.235 > icsd-net.2
       (If  the _/_e_t_c_/_a_t_a_l_k_._n_a_m_e_s doesn't exist or doesn't contain an entry for
       some AppleTalk host/net number, addresses are printed in numeric form.)
       In the first example, NBP (DDP port 2) on net 144.1 node 209 is sending
       to whatever is listening on port 220 of net icsd node 112.  The  second
       line  is  the  same  except  the  full name of the source node is known
       (`office').  The third line is a send from port 235 on net jssmag  node
       149  to  broadcast  on  the  icsd-net NBP port (note that the broadcast
       address (255) is indicated by a net name with no host number - for this
       reason  it's  a  good idea to keep node names and net names distinct in
       /etc/atalk.names).

       NBP (name binding protocol) and ATP  (AppleTalk  transaction  protocol)
       packets have their contents interpreted.  Other protocols just dump the
       protocol name (or number if no name is registered for the protocol) and
       packet size.

       NNBBPP ppaacckkeettss are formatted like the following examples:
              icsd-net.112.220 > jssmag.2: nbp-lkup 190: "=:LaserWriter@*"
              jssmag.209.2 > icsd-net.112.220: nbp-reply 190: "RM1140:LaserWriter@*" 250
              techpit.2 > icsd-net.112.220: nbp-reply 190: "techpit:LaserWriter@*" 186
       The  first  line  is a name lookup request for laserwriters sent by net
       icsd host 112 and broadcast on net jssmag.  The nbp id for  the  lookup
       is  190.   The second line shows a reply for this request (note that it
       has the same id) from host jssmag.209 saying that it has a  laserwriter
       resource  named  "RM1140"  registered  on  port 250.  The third line is
       another reply to the same request saying host techpit  has  laserwriter
       "techpit" registered on port 186.

       AATTPP ppaacckkeett formatting is demonstrated by the following example:
              jssmag.209.165 > helios.132: atp-req  12266<0-7> 0xae030001
              helios.132 > jssmag.209.165: atp-resp 12266:0 (512) 0xae040000
              helios.132 > jssmag.209.165: atp-resp 12266:1 (512) 0xae040000
              helios.132 > jssmag.209.165: atp-resp 12266:2 (512) 0xae040000
              helios.132 > jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
              helios.132 > jssmag.209.165: atp-resp 12266:4 (512) 0xae040000
              helios.132 > jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
              helios.132 > jssmag.209.165: atp-resp 12266:6 (512) 0xae040000
              helios.132 > jssmag.209.165: atp-resp*12266:7 (512) 0xae040000
              jssmag.209.165 > helios.132: atp-req  12266<3,5> 0xae030001
              helios.132 > jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
              helios.132 > jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
              jssmag.209.165 > helios.132: atp-rel  12266<0-7> 0xae030001
              jssmag.209.133 > helios.132: atp-req* 12267<0-7> 0xae030002
       Jssmag.209  initiates transaction id 12266 with host helios by request-
       ing up to 8 packets (the `<0-7>').  The hex number at the  end  of  the
       line is the value of the `userdata' field in the request.

       Helios  responds  with  8 512-byte packets.  The `:digit' following the
       transaction id gives the packet sequence number in the transaction  and
       the number in parens is the amount of data in the packet, excluding the
       atp header.  The `*' on packet 7 indicates that the EOM bit was set.

       Jssmag.209 then requests that packets 3 & 5 be  retransmitted.   Helios
       resends  them  then jssmag.209 releases the transaction.  Finally, jss-
       mag.209 initiates the next request.  The `*' on the  request  indicates
       that XO (`exactly once') was _n_o_t set.


       IIPP FFrraaggmmeennttaattiioonn

       Fragmented Internet datagrams are printed as
              ((ffrraagg _i_d::_s_i_z_e@@_o_f_f_s_e_t++))
              ((ffrraagg _i_d::_s_i_z_e@@_o_f_f_s_e_t))
       (The  first  form indicates there are more fragments.  The second indi-
       cates this is the last fragment.)

       _I_d is the fragment id.  _S_i_z_e is the fragment size (in bytes)  excluding
       the  IP  header.   _O_f_f_s_e_t  is  this fragment's offset (in bytes) in the
       original datagram.

       The fragment information is output for each fragment.  The first  frag-
       ment  contains  the  higher  level protocol header and the frag info is
       printed after the protocol info.  Fragments after the first contain  no
       higher  level  protocol  header  and the frag info is printed after the
       source and destination addresses.  For example, here is part of an  ftp
       from  arizona.edu to lbl-rtsg.arpa over a CSNET connection that doesn't
       appear to handle 576 byte datagrams:
              arizona.ftp-data > rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)
              arizona > rtsg: (frag 595a:204@328)
              rtsg.1170 > arizona.ftp-data: . ack 1536 win 2560
       There are a couple of things to note here:  First, addresses in the 2nd
       line  don't  include  port  numbers.   This is because the TCP protocol
       information is all in the first fragment and we have no idea  what  the
       port  or  sequence numbers are when we print the later fragments.  Sec-
       ond, the tcp sequence information in the first line is  printed  as  if
       there  were  308  bytes of user data when, in fact, there are 512 bytes
       (308 in the first frag and 204 in the second).  If you are looking  for
       holes  in  the  sequence space or trying to match up acks with packets,
       this can fool you.

       A packet with the IP _d_o_n_'_t _f_r_a_g_m_e_n_t flag  is  marked  with  a  trailing
       ((DDFF)).

       TTiimmeessttaammppss

       By  default,  all  output lines are preceded by a timestamp.  The time-
       stamp is the current clock time in the form
              _h_h_:_m_m_:_s_s_._f_r_a_c
       and is as accurate as the kernel's clock.  The timestamp  reflects  the
       time  the  kernel  first saw the packet.  No attempt is made to account
       for the time lag between when the Ethernet interface removed the packet
       from  the wire and when the kernel serviced the `new packet' interrupt.

PPAACCKKEETT MMEETTAADDAATTAA FFIILLTTEERR
       Use packet metadata filter expression to match packets against descrip-
       tive  information about the packet: interface, process, service type or
       direction.

       Note this is meaningful only with capture files  in  the  Pcap-ng  file
       format or for interfaces supporting the PKTAP data link type.

       The syntax supports the following operators:

              oorr     logical or
              aanndd    logical and
              nnoott    negation
              ((......))  to group sub-expressions
              ==      is equal
              !!==     is not equal
              ||||     logical or (alternate)
              &&&&     logical and (alternate)
              !!      negation (alternate)

       The  syntax  support  the  following keywords to denote which of packet
       metadata contents is to be compared:

              iiff     interface name
              pprroocc   process name
              ppiidd    process ID
              ssvvcc    service class
              ddiirr    direction
              eepprroocc  effective process name
              eeppiidd   effective process ID

       For example to filter packets from interface en0 "sent" by the  process
       named "nc" or incoming packet not on interface en0:

              --QQ ""(( iiff==eenn00 aanndd pprroocc ==nncc )) |||| ((iiff !!== eenn00 aanndd ddiirr==iinn))""

       Note  that  a complex packet metadata filter expression needs to be put
       in quotes as the option --QQ takes a single string parameter.

SSEEEE AALLSSOO
       stty(1),  pcap(3PCAP),  bpf(4),  nit(4P),  pcap-savefile(5),  pcap-fil-
       ter(7), pcap-tstamp-type(7)

AAUUTTHHOORRSS
       The original authors are:

       Van  Jacobson,  Craig  Leres  and  Steven  McCanne, all of the Lawrence
       Berkeley National Laboratory, University of California, Berkeley, CA.

       It is currently being maintained by tcpdump.org.

       The current version is available via http:

              _h_t_t_p_:_/_/_w_w_w_._t_c_p_d_u_m_p_._o_r_g_/

       The original distribution is available via anonymous ftp:

              _f_t_p_:_/_/_f_t_p_._e_e_._l_b_l_._g_o_v_/_o_l_d_/_t_c_p_d_u_m_p_._t_a_r_._Z

       IPv6/IPsec support is added by WIDE/KAME project.   This  program  uses
       Eric Young's SSLeay library, under specific configurations.

BBUUGGSS
       Please  send problems, bugs, questions, desirable enhancements, patches
       etc. to:

              tcpdump-workers@lists.tcpdump.org

       NIT doesn't let you watch your own outbound traffic, BPF will.  We rec-
       ommend that you use the latter.

       On Linux systems with 2.0[.x] kernels:

              packets on the loopback device will be seen twice;

              packet filtering cannot be done in the kernel, so that all pack-
              ets must be copied from the kernel in order to  be  filtered  in
              user mode;

              all  of  a  packet, not just the part that's within the snapshot
              length, will be copied from the kernel (the 2.0[.x] packet  cap-
              ture  mechanism, if asked to copy only part of a packet to user-
              land, will not report the true length of the packet; this  would
              cause most IP packets to get an error from ttccppdduummpp);

              capturing on some PPP devices won't work correctly.

       We recommend that you upgrade to a 2.2 or later kernel.

       Some  attempt should be made to reassemble IP fragments or, at least to
       compute the right length for the higher level protocol.

       Name server inverse queries are not dumped correctly: the (empty) ques-
       tion  section  is printed rather than real query in the answer section.
       Some believe that inverse queries are themselves a bug  and  prefer  to
       fix the program generating them rather than _t_c_p_d_u_m_p.

       A  packet  trace  that crosses a daylight savings time change will give
       skewed time stamps (the time change is ignored).

       Filter expressions on fields other than those  in  Token  Ring  headers
       will not correctly handle source-routed Token Ring packets.

       Filter  expressions  on  fields other than those in 802.11 headers will
       not correctly handle 802.11 data packets with both To DS  and  From  DS
       set.

       iipp66  pprroottoo  should  chase header chain, but at this moment it does not.
       iipp66 pprroottoocchhaaiinn is supplied for this behavior.

       Arithmetic expression against transport  layer  headers,  like  ttccpp[[00]],
       does not work against IPv6 packets.  It only looks at IPv4 packets.



                                 12 July 2012                       TCPDUMP(1)
